// Various build options to test with:

// $(ProjectDir)
// -v9 Test.a

// C:\work\C64\Scroller
// -v3 --msvc ScrollEntry.a

// C:\work\c64\Tusari2
// -v4 --msvc --lib ../Scroller/ ScrollEntry.a ScrollEntry_Tusari.a ScrollEntryAfter.a

ACME TODO file.

* It might be possible to find the current pyton file and line being executed and pass that to the assembly PDB information




* Command line option to define labels



* Look into structure storage and label generation. A '.' is an undefined value, no default value when being used
	!struct SomeData {
		a	!by .
		b	!by .
		c	!word .
	}
	Will create the labels with offsets to the named members:
		SomeData_a = 0
		SomeData_b = 1
		SomeData_c = 2
	Then using it with:
	* = $100
	someLabel +SomeData 4 , 5 , 1234
	Will automatically create data in memory according to the structure with these variables:
		someLabel_a = $100
		someLabel_b = $101
		someLabel_c = $102
		someLabel_SomeData_a = 0
		someLabel_SomeData_b = 1
		someLabel_SomeData_c = 2



* Look into VSCode remote debugging into Vice with PDB parsing to enhance the source view



* Look into VS to Vice debugging with ACME
	https://blog.3d-logic.com/2012/05/12/introducing-vintage-studio/

	

* Code re-ordering and register optimisation
	Especially the case where we have code like this:
	!macro FOO {
		lda #$ff
		sta address
	}
	!macro BAR {
		lda #$ff
		sta address2
	}
		+FOO
		+BAR
	This would typically result in output code:
		lda #$ff
		sta address
		lda #$ff
		sta address2
	Instead optimise this so that it results in:
		lda #$ff
		sta address
		sta address2
	This can be done if there are no references to branch/jump/indrect/store in-between the two stores.
	>> Shifted 16 bit values:
		lda .workOffset
		sec
		sbc #3
		sta .workOffset
		bcs .noBorrow
		dec .workOffset+1
	.noBorrow
	;workOffset = ((workOffset-3)<<8) + source[curLen];
		lda .workOffset
		sta .workOffset+1
		jsr ReturnA...
		sta .workOffset
	Can become:
		lda .workOffset
		sec
		sbc #3
		; Note: The bottom byte is discarded due to the result <<8, the top byte is replaced...
		sta .workOffset+1
		jsr ReturnA...
		sta .workOffset





* Dead strip code in zones where labels (their memory addresses) are not referenced at all by anything outside that zone.



* Add assembler zone documentation
	!entry	- Document entry status/register/memory locations
	!return	- Document returned status/register/memory locations
	!trashed	- Document trashed status/register/memory locations. Like !return but makes the unknown/trashed state explicit.
	!preserve	- Make status/register/memory explicitly preserved
	!irq		- Flag this as IRQ code
	When any of the above are used then also track all status/register/memory usage for the zone

	


* Use the assembler zone documentation and static analysis to warn when conflicting status/register/memory locations are used in code.
	If the calling zone uses status/register/memory that the called zone does then output an error.
	For example:
	!zn {
	!return A
		foo
			lda #0
>>Warning doThing trashes A>>	jsr doThing
			rts
	}
	!zn {
	!entry
	!return
	doThing
		lda #0
		rts



* When !irq is used, analyse the code to ensure that !preserve registers/locations are restored

	


* Optimising assembly with zone using !optimise
	Use the assembler zone documentation and static analysis to automatically pick optimisations for a zone
	For example:
	!zn {
	!optimise speed
	!entry Y
	!return X , EQ	; Returns X and one of the EQ/NE status
	!trash A , Y , CC , VS , MI	; Can trash registers and CC/CS VC/VS MI/PL status
	foo
		iny
		iny
		iny
		iny
		tya
		; Flags that this is the instruction that will return the destination in X
		!return	tax
		; If any code alters X after this !return, in this scope, then an assembler error is generated
		rts
	}
	Would optimise to:
	foo
		tya
		clc
		adc #4
		tax
		rts

	>> Or:
		lda #0
		sta workLen
		sta workLen+1
		jsr GetNextBitIntoCarryKillA
		rol workLen
		jsr GetNextBitIntoCarryKillA
		rol workLen
		lda workLen
		ora workLen+1
		bne not0
		lda #1
		sta .workLen
	>> Optimises to:
		lda #0
		sta .workLen
		sta .workLen+1

		jsr .GetNextBitIntoCarryKillA
		rol .workLen
		jsr .GetNextBitIntoCarryKillA
		rol .workLen

		; Note: Status from above
		bne .not0

		; Equivalent since .workLen = 0
		inc .workLen




* !range <label> , <start> , <end> , <step>
	Like !for but has more options for start and step values





* !bank <bank number>
	Creates or accesses new 64KB (up to) memory banks which allows code/data to be huge.
	The corresponding PC is maintained for each bank.
	Each bank is saved as a distinct file, new addition to the base filename.
	The PDB would need bank information and the remote debugger would need some way of identifying the bank being executed, perhaps by noting the current cartridge bank select by reading any active cartridge IO space from Vice/BDD6502.





