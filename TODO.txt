// Various build options to test with:

// $(ProjectDir)
// -v9 Test.a

// C:\work\C64\Scroller
// -v3 --msvc ScrollEntry.a

// C:\work\c64\Tusari2
// -v4 --msvc --lib ../Scroller/ ScrollEntry.a ScrollEntry_Tusari.a ScrollEntryAfter.a

ACME TODO file.

* Command line option to define labels



* Look into structure storage and label generation. A '.' is an undefined value, no default value when being used
	!struct SomeData {
		a	!by .
		b	!by .
		c	!word .
	}
	Will create the labels with offsets to the named members:
		SomeData_a = 0
		SomeData_b = 1
		SomeData_c = 2
	Then using it with:
	* = $100
	someLabel +SomeData 4 , 5 , 1234
	Will automatically create data in memory according to the structure with these variables:
		someLabel_a = $100
		someLabel_b = $101
		someLabel_c = $102
		someLabel_SomeData_a = 0
		someLabel_SomeData_b = 1
		someLabel_SomeData_c = 2



* Look into VSCode remote debugging into Vice with PDB parsing to enhance the source view



* Look into VS to Vice debugging with ACME
	https://blog.3d-logic.com/2012/05/12/introducing-vintage-studio/

	

* Code re-ordering and register optimisation
	Especially the case where we have code like this:
	!macro FOO {
		lda #$ff
		sta address
	}
	!macro BAR {
		lda #$ff
		sta address2
	}
		+FOO
		+BAR
	This would typically result in output code:
		lda #$ff
		sta address
		lda #$ff
		sta address2
	Instead optimise this so that it results in:
		lda #$ff
		sta address
		sta address2
	This can be done if there are no references to branch/jump/indrect/store in-between the two stores.
	>> Shifted 16 bit values:
		lda .workOffset
		sec
		sbc #3
		sta .workOffset
		bcs .noBorrow
		dec .workOffset+1
	.noBorrow
	;workOffset = ((workOffset-3)<<8) + source[curLen];
		lda .workOffset
		sta .workOffset+1
		jsr ReturnA...
		sta .workOffset
	Can become:
		lda .workOffset
		sec
		sbc #3
		; Note: The bottom byte is discarded due to the result <<8, the top byte is replaced...
		sta .workOffset+1
		jsr ReturnA...
		sta .workOffset





* Dead strip code in zones where labels (their memory addresses) are not referenced at all by anything outside that zone.



* Add assembler zone documentation
	!entry	- Document entry status/register/memory locations
	!return	- Document returned status/register/memory locations
	!trashed	- Document trashed status/register/memory locations. Like !return but makes the unknown/trashed state explicit.
	!preserve	- Make status/register/memory explicitly preserved
	!irq		- Flag this as IRQ code
	When any of the above are used then also track all status/register/memory usage for the zone

	


* Use the assembler zone documentation and static analysis to warn when conflicting status/register/memory locations are used in code.
	If the calling zone uses status/register/memory that the called zone does then output an error.
	For example:
	!zn {
	!return A
		foo
			lda #0
>>Warning doThing trashes A>>	jsr doThing
			rts
	}
	!zn {
	!entry
	!return
	doThing
		lda #0
		rts



* When !irq is used, analyse the code to ensure that !preserve registers/locations are restored

	


* Optimising assembly with zone using !optimise
	Use the assembler zone documentation and static analysis to automatically pick optimisations for a zone
	For example:
	!zn {
	!optimise speed
	!entry Y
	!return X , EQ	; Returns X and one of the EQ/NE status
	!trash A , Y , CC , VS , MI	; Can trash registers and CC/CS VC/VS MI/PL status
	foo
		iny
		iny
		iny
		iny
		tya
		; Flags that this is the instruction that will return the destination in X
		!return	tax
		; If any code alters X after this !return, in this scope, then an assembler error is generated
		rts
	}
	Would optimise to:
	foo
		tya
		clc
		adc #4
		tax
		rts

	>> Or:
		lda #0
		sta workLen
		sta workLen+1
		jsr GetNextBitIntoCarryKillA
		rol workLen
		jsr GetNextBitIntoCarryKillA
		rol workLen
		lda workLen
		ora workLen+1
		bne not0
		lda #1
		sta .workLen
	>> Optimises to:
		lda #0
		sta .workLen
		sta .workLen+1

		jsr .GetNextBitIntoCarryKillA
		rol .workLen
		jsr .GetNextBitIntoCarryKillA
		rol .workLen

		; Note: Status from above
		bne .not0

		; Equivalent since .workLen = 0
		inc .workLen




* !range <label> , <start> , <end> , <step>
	Like !for but has more options for start and step values





* !bank <bank number>
	Creates or accesses new 64KB (up to) memory banks which allows code/data to be huge.
	The corresponding PC is maintained for each bank.
	Each bank is saved as a distinct file, new addition to the base filename.
	The PDB would need bank information and the remote debugger would need some way of identifying the bank being executed, perhaps by noting the current cartridge bank select by reading any active cartridge IO space from Vice/BDD6502.





* Scripting options?
	* Using a PO ! like:
		* !scriptsimple
		* !scriptpython
			https://docs.python.org/3/extending/embedding.html
			https://docs.python.org/3/extending/embedding.html#extending-embedded-python
			https://docs.python.org/3/c-api/index.html#c-api-index
			Extension function example: https://docs.python.org/3/extending/extending.html#a-simple-example
				Could create: acme.source("text")
					acme.binary(bytearray)
						https://www.geeksforgeeks.org/python-bytearray-function/
					acme.setPC(address)
					acme.addLabel(text)
					acme.newZone()
						>> PO_zone
							>> Parse_optional_block?
					acme.startZone()
					acme.endZone()
					* The source added via this function can be processed like !source ?
						>> PO_source
							>> Parse_and_close_file
								>> new_input.source_is_ram = TRUE;
			"%LOCALAPPDATA%\Programs\Python\Python39\include"
				Python.h
			"%LOCALAPPDATA%\Programs\Python\Python39\Libs"
				python39.lib
			>> Can also use some of the code in PO_for for define an inline pyton code block
				loop_body = Input_skip_or_store_block(TRUE)
			** Two options:
				!scriptpython {
				# Some python code inside braces
				}
				!scriptpython "filename.py"
	* Key functionality would be:
		* Read currently defined labels, and write new values
		* Read and write assembled memory
		* Inject new text assembly to be assembled outside of the script
		* Execute scripts from external files would probably be the most common use case.
			It might make sense to export the labels to a python format, ready to be imported?
				It would be slow, but easier than relying on durect to Python memory injection.
	poArgs = [0, 1234, "hello"]
	# address = (bank, address)
	addressToLabels = {
		(0, 1234): [
			{"name": ".aLabel",
				"zone": 1,
				"used": True
				},
			{"name": "global",
				"zone": 0}
		],
		(0, 1235): {"just this one"}
	}

	labelToAddresses = {
		".aLabel": [(0, 1234)],
		".l1": [(1, 134), (0, 436)]
	}
	>> Note: c:\users\martin piper\appdata\local\programs\python\python39\include\pyport.h
		Needed:
			// NOTE: Wrong header
			//#include <inttypes.h>
			#include <stdint.h>
		>> LINK : fatal error LNK1104: cannot open file 'python39_d.lib'
			C:\Users\Martin Piper\AppData\Local\Programs\Python\Python39\libs
				Needed to copy "python39.lib" to "python39_d.lib"
	>> The EXE type needed to be changed to x64 and python.dll is x64
	* Done: For anonymous errors like: Error - File TestPython.py, line 1 (Zone <untitled>): Value not defined.
		These need to emit the problematic line which includes the label etc...
			throw_message can output the information
			However Parse_until_eob_or_eof will need to "save" the last processed line
				>> ALU_any_result
					>> parse_expression
						>> Perhaps this can save the last expression that was parsed?
							Which can then be output
	* Done: !scriptpythonfile "TestPython.py" , <parameter 1> , <parameter n>
	* Done: !scriptpythoninline <parameter 1> , <parameter n> {
		For these can use the !for model
	* Done: Automatically include the "import acme", then parameters
	* TODO: Automatically add labels
	* Done: Change back to use x86 build from: https://www.python.org/downloads/release/python-390/
		https://www.python.org/ftp/python/3.9.0/python-3.9.0.exe
			C:\Users\Martin Piper\AppData\Local\Programs\Python\Python39-32
