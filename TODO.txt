// Various build options to test with:

// $(ProjectDir)
// -v9 Test.a

// C:\work\C64\Scroller
// -v3 --msvc ScrollEntry.a

// C:\work\c64\Tusari2
// -v4 --msvc --lib ../Scroller/ ScrollEntry.a ScrollEntry_Tusari.a ScrollEntryAfter.a

ACME TODO file.

* Command line option to define labels



* !swizzle 64 , 3
	This will take the previous 256*3 bytes of data (from the current PC) and apply a swizzle, which converts row oriented data into columns, or vice versa.
	For example if there was data compresed of 256 repeating patterns of: !word value !by value : so 256 x 3 bytes
	It will convert the data into:
		256 bytes of < bytes (lo !word)
		256 bytes of > bytes (hi !word)
		256 bytes of byte values




* Implement these extensions to the formula value parser
	* [d LABEL or any formula]
	* [f "filename" , LABEL or any formula]
	* !set LABEL = [d LABEL or hex value for ADDRESS]
		Will set label equal to the unsigned byte value of the assembled data
		This is useful for importing binart data with !bin and then processing the data to produce label offsets into it.
	* !set LABEL = [f "filename" , offset]
		Will set label equal to the unsigned byte value at file offset for filename.
		This is useful for processing the file structure of a binary file to produce label values.
	> PO_set
	> ALU_any_result
	> parse_expression
	>> Add test to TestForForwardReference.a
	> Can treat these like: case '(':// left parenthesis
	// Done: Need to read byte at memory
		real_output?
		write_ptr?
		Might need something to get a byte, like real_output but gets not stores
			>>getByteAtAddr
	* Surely this would have been easier with peek()/poke()/filebyte() etc?
		Like: PREDEFNODE(s_sin,	&ops_sin),
		Or: PREDEFNODE("int",	&ops_int),
	* I think it's going to be easier to enhance this to add string function parameter parsing:
			if(Tree_easy_scan(function_tree, &node_body, function_dyna_buf))
			PUSH_OPERATOR((op_t*) node_body);
			Use Input_read_filename() like for PO_binary()?
		filebyte() works



* Look into structure storage and label generation. A '.' is an undefined value, no default value when being used
	!struct SomeData {
		a	!by .
		b	!by .
		c	!word .
	}
	Will create the labels with offsets to the named members:
		SomeData_a = 0
		SomeData_b = 1
		SomeData_c = 2
	Then using it with:
	* = $100
	someLabel +SomeData 4 , 5 , 1234
	Will automatically create data in memory according to the structure with these variables:
		someLabel_a = $100
		someLabel_b = $101
		someLabel_c = $102
		someLabel_SomeData_a = 0
		someLabel_SomeData_b = 1
		someLabel_SomeData_c = 2



* Look into VSCode remote debugging into Vice with PDB parsing to enhance the source view



* Look into VS to Vice debugging with ACME
	https://blog.3d-logic.com/2012/05/12/introducing-vintage-studio/

	

* Code re-ordering and register optimisation
	Especially the case where we have code like this:
	!macro FOO {
		lda #$ff
		sta address
	}
	!macro BAR {
		lda #$ff
		sta address2
	}
		+FOO
		+BAR
	This would typically result in output code:
		lda #$ff
		sta address
		lda #$ff
		sta address2
	Instead optimise this so that it results in:
		lda #$ff
		sta address
		sta address2
	This can be done if there are no references to branch/jump/indrect/store in-between the two stores.

	

* Dead strip code in zones where labels (their memory addresses) are not referenced at all by anything outside that zone.



* Add assembler zone documentation
	!entry	- Document entry status/register/memory locations
	!return	- Document returned status/register/memory locations
	!trashed	- Document trashed status/register/memory locations. Like !return but makes the unknown/trashed state explicit.
	!preserve	- Make status/register/memory explicitly preserved
	!irq		- Flag this as IRQ code
	When any of the above are used then also track all status/register/memory usage for the zone

	


* Use the assembler zone documentation and static analysis to warn when conflicting status/register/memory locations are used in code.
	If the calling zone uses status/register/memory that the called zone does then output an error.
	For example:
	!zn {
	!return A
		foo
			lda #0
>>Warning doThing trashes A>>	jsr doThing
			rts
	}
	!zn {
	!entry
	!return
	doThing
		lda #0
		rts



* When !irq is used, analyse the code to ensure that !preserve registers/locations are restored

	


* Optimising assembly with zone using !optimise
	Use the assembler zone documentation and static analysis to automatically pick optimisations for a zone
	For example:
	!zn {
	!optimise speed
	!entry Y
	!return X , EQ	; Returns X and one of the EQ/NE status
	!trash A , Y , CC , VS , MI	; Can trash registers and CC/CS VC/VS MI/PL status
	foo
		iny
		iny
		iny
		iny
		tya
		; Flags that this is the instruction that will return the destination in X
		!return	tax
		; If any code alters X after this !return, in this scope, then an assembler error is generated
		rts
	}
	Would optimise to:
	foo
		tya
		clc
		adc #4
		tax
		rts

	>> Or:
		lda #0
		sta workLen
		sta workLen+1
		jsr GetNextBitIntoCarryKillA
		rol workLen
		jsr GetNextBitIntoCarryKillA
		rol workLen
		lda workLen
		ora workLen+1
		bne not0
		lda #1
		sta .workLen
	>> Optimises to:
		lda #0
		sta .workLen
		sta .workLen+1

		jsr .GetNextBitIntoCarryKillA
		rol .workLen
		jsr .GetNextBitIntoCarryKillA
		rol .workLen

		; Note: Status from above
		bne .not0

		; Equivalent since .workLen = 0
		inc .workLen




* !range <label> , <start> , <end> , <step>
	Like !for but has more options for start and step values
